# UV Dependency Blocker Hook - Specification

## Metadata

- **Hook Name**: uv_dependency_blocker.py
- **Hook Category**: PreToolUse
- **Version**: 1.0.0
- **Author**: Claude Code Hook Expert
- **Last Updated**: 2025-10-30

## 1. Purpose

Prevent direct editing of Python dependency files to enforce the use of UV commands for dependency management during development. This ensures consistency, reproducibility, and proper dependency tracking across the project lifecycle while leveraging UV's advanced dependency resolution and lock file management.

## 2. Problem Statement

Direct manual editing of Python dependency files bypasses UV's dependency management workflow and creates several critical issues:

1. **Lock File Inconsistency**: Manual edits to `requirements.txt` or `pyproject.toml` don't update `uv.lock`, breaking reproducibility
2. **Dependency Resolution Bypass**: UV's sophisticated dependency resolver won't validate compatibility when files are edited directly
3. **Version Conflicts**: Manual version specifications may conflict with other dependencies without validation
4. **Missing Transitive Dependencies**: Adding packages manually doesn't include their required dependencies
5. **Platform-Specific Issues**: Direct edits miss UV's platform-specific dependency handling
6. **Workflow Fragmentation**: Mixing manual edits with UV commands creates confusion about the source of truth
7. **Team Synchronization**: Manual changes harder to track, review, and replicate across team members

## 3. Objectives

1. **Enforce UV Workflow**: Block direct edits to dependency files, requiring UV commands instead
2. **Provide Clear Guidance**: Offer specific UV command alternatives for common operations
3. **Comprehensive Coverage**: Handle all common Python dependency file formats
4. **Path Agnostic**: Detect dependency files regardless of location in project
5. **Fail-safe Behavior**: Allow operations on errors to avoid disrupting development
6. **Zero Dependencies**: Use only Python standard library for maximum portability
7. **Integration**: Leverage shared utilities for consistency across pre_tools hooks
8. **Educational**: Help developers learn proper UV workflows through clear messaging

## 4. Hook Event Selection

### Selected Event: PreToolUse

**Rationale**:
- Executes **before** file modifications, preventing unwanted edits
- Receives complete tool parameters for validation
- Can deny operations via `permissionDecision: "deny"`
- Supports structured error messages with UV command alternatives
- Ideal for workflow enforcement and policy validation

**Alternative Events Considered**:
- **PostToolUse**: Too late - files would already be modified
- **UserPromptSubmit**: Too early - file paths not yet available
- **SessionStart**: Not appropriate for per-operation validation

## 5. Tool Matchers

The hook monitors file operation tools that can modify dependency files:

### File Operation Tools

1. **Write**: File creation and overwriting
   - Validates `tool_input.file_path`
   - Blocks creating new dependency files manually
   - Most common file modification tool

2. **Edit**: File content modification
   - Validates `tool_input.file_path`
   - Blocks editing existing dependency files
   - Catches incremental changes

### Tools Explicitly Excluded

- **Read**: Read-only operations don't modify files
- **Bash**: Too complex to reliably parse all file modification patterns
  - Note: Users could bypass via bash commands, but this is acceptable for workflow enforcement (not security)
  - Focus on catching accidental edits via Write/Edit tools
- **NotebookEdit**: Not relevant for dependency management
- **Glob/Grep**: Search operations only

### Matcher Configuration

```json
{
  "matcher": "Write|Edit"
}
```

## 6. Dependency File Patterns

### 6.1 Files to Block

```python
DEPENDENCY_FILE_PATTERNS = [
    # UV-specific files
    "uv.lock",           # UV lock file - generated by UV, never manual edit

    # Modern Python packaging
    "pyproject.toml",    # PEP 621 project metadata and dependencies

    # Legacy pip formats
    "requirements.txt",         # Standard requirements
    "requirements-dev.txt",     # Development dependencies
    "requirements-test.txt",    # Test dependencies
    "requirements-prod.txt",    # Production dependencies
    # Pattern: requirements*.txt catches all variants

    # Pipenv files
    "Pipfile",          # Pipenv dependency specification
    "Pipfile.lock",     # Pipenv lock file
]
```

### 6.2 Pattern Matching Strategy

**Filename-based Detection**:
- Extract basename from file path: `os.path.basename(file_path)`
- Case-insensitive matching (for Windows/macOS compatibility)
- Support files in any directory (not just project root)

**Rationale for Inclusive Approach**:
- Catch dependencies in subdirectories (e.g., `docs/requirements.txt`)
- Handle non-standard project structures
- Prefer false positives (can disable hook) over false negatives (missing edits)

### 6.3 Special Cases

#### pyproject.toml Considerations

**Issue**: pyproject.toml contains both dependency and non-dependency information:
- `[project.dependencies]` - Runtime dependencies
- `[project.optional-dependencies]` - Optional dependency groups
- `[tool.*]` - Tool configurations (ruff, pytest, etc.)
- `[build-system]` - Build configuration
- `[project]` - Package metadata (name, version, description)

**Decision**: Block ALL pyproject.toml edits

**Rationale**:
1. Most pyproject.toml edits in UV projects are dependency-related
2. Non-dependency metadata can be added via `uv init` or temporarily disabling hook
3. Keeps hook implementation simple, fast, and reliable
4. Content-aware parsing would be complex and slow
5. Clear documentation allows users to make informed decisions

**Alternative Workflows**:
- Use `uv add --dev ruff` to add tool dependencies
- Temporarily disable hook for metadata-only changes
- Use `uv init` to initialize project structure

## 7. Input Schema

### Standard PreToolUse Input Structure

```typescript
{
  session_id: string,           // Unique session identifier
  transcript_path: string,      // Path to transcript JSONL
  cwd: string,                  // Current working directory
  hook_event_name: "PreToolUse",
  tool_name: string,            // "Write" | "Edit"
  tool_input: {                 // Tool-specific parameters
    file_path: string,          // Target file path (required)
    content?: string,           // File content (Write tool)
    old_string?: string,        // String to replace (Edit tool)
    new_string?: string,        // Replacement string (Edit tool)
  }
}
```

### Tool-Specific Input Handling

#### Write Tool
```python
file_path = tool_input.get("file_path", "")
# Creating or overwriting dependency files
```

#### Edit Tool
```python
file_path = tool_input.get("file_path", "")
# Modifying existing dependency files
```

## 8. Output Schema

### JSON Output Format

```typescript
{
  hookSpecificOutput: {
    hookEventName: "PreToolUse",
    permissionDecision: "allow" | "deny" | "ask",
    permissionDecisionReason: string
  },
  suppressOutput?: boolean  // Optional: hide from transcript
}
```

### Decision Types

#### 8.1 Allow Decision

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "allow",
    "permissionDecisionReason": "Not a Python dependency file"
  }
}
```

**Used when**:
- File is not a recognized dependency file
- Tool is not Write or Edit
- Error occurs (fail-safe behavior)

#### 8.2 Deny Decision - uv.lock

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "ðŸ”’ Blocked: Direct editing of UV lock file\n\nFile: uv.lock\n\nUV lock files are automatically generated and should never be edited manually.\n\nTo update the lock file:\n  uv lock                    # Regenerate lock file from dependencies\n  uv lock --upgrade          # Upgrade all dependencies to latest compatible versions\n  uv lock --upgrade-package <pkg>  # Upgrade specific package\n\nTo add dependencies:\n  uv add <package>           # Add to dependencies and update lock\n  uv add --dev <package>     # Add to dev dependencies\n\nTo remove dependencies:\n  uv remove <package>        # Remove and update lock\n\nLearn more: https://docs.astral.sh/uv/concepts/dependencies/"
  },
  "suppressOutput": true
}
```

#### 8.3 Deny Decision - pyproject.toml

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "ðŸ“¦ Blocked: Direct editing of pyproject.toml\n\nFile: pyproject.toml\n\nDirect edits bypass UV's dependency management. Use UV commands for consistency.\n\nCommon operations:\n  uv add <package>           # Add dependency\n  uv add --dev <package>     # Add dev dependency\n  uv add --optional <group> <package>  # Add to optional group\n  uv remove <package>        # Remove dependency\n  uv lock                    # Update lock file after changes\n\nFor non-dependency edits (metadata, tool config):\n  - Temporarily disable this hook if needed\n  - Use uv init for initial project setup\n\nLearn more: https://docs.astral.sh/uv/concepts/dependencies/"
  },
  "suppressOutput": true
}
```

#### 8.4 Deny Decision - requirements.txt

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "ðŸ“‹ Blocked: Direct editing of requirements file\n\nFile: requirements.txt\n\nDirect edits to requirements.txt bypass UV's dependency resolution.\n\nMigrate to modern UV workflow:\n  uv add <package>           # Add dependency (updates pyproject.toml + uv.lock)\n  uv remove <package>        # Remove dependency\n  uv sync                    # Sync environment from lock file\n\nIf you must use requirements.txt:\n  uv pip install <package>   # Install and update requirements.txt\n  uv pip compile requirements.in -o requirements.txt  # Compile from .in file\n\nConsider migrating to pyproject.toml for better dependency management.\n\nLearn more: https://docs.astral.sh/uv/pip/compile/"
  },
  "suppressOutput": true
}
```

#### 8.5 Deny Decision - Pipfile

```json
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "permissionDecision": "deny",
    "permissionDecisionReason": "ðŸ”§ Blocked: Direct editing of Pipfile\n\nFile: Pipfile\n\nPipfile/Pipfile.lock should be managed by pipenv or migrated to UV.\n\nIf using Pipenv:\n  pipenv install <package>   # Add dependency\n  pipenv install --dev <package>  # Add dev dependency\n  pipenv uninstall <package> # Remove dependency\n\nConsider migrating to UV for better performance:\n  # Export current dependencies\n  pipenv requirements > requirements.txt\n  \n  # Migrate to UV\n  uv init\n  uv add $(cat requirements.txt | grep -v '^#' | grep -v '^-e')\n\nLearn more: https://docs.astral.sh/uv/guides/projects/"
  },
  "suppressOutput": true
}
```

## 9. Validation Logic

### 9.1 Dependency File Detection

```python
def is_dependency_file(file_path: str) -> tuple[bool, str]:
    """
    Check if file path is a Python dependency file.

    Args:
        file_path: Path to check (can be absolute or relative)

    Returns:
        Tuple of (is_dependency_file, file_type)
        - is_dependency_file: True if it's a dependency file
        - file_type: One of "uv.lock", "pyproject.toml", "requirements.txt",
                     "Pipfile", "Pipfile.lock", or ""

    Examples:
        >>> is_dependency_file("/project/uv.lock")
        (True, "uv.lock")
        >>> is_dependency_file("./requirements-dev.txt")
        (True, "requirements.txt")
        >>> is_dependency_file("/project/src/main.py")
        (False, "")
    """
    if not file_path:
        return (False, "")

    # Extract basename for pattern matching
    filename = os.path.basename(file_path).lower()

    # UV lock file
    if filename == "uv.lock":
        return (True, "uv.lock")

    # pyproject.toml
    if filename == "pyproject.toml":
        return (True, "pyproject.toml")

    # requirements.txt variants (case-insensitive)
    if filename.startswith("requirements") and filename.endswith(".txt"):
        return (True, "requirements.txt")

    # Pipfile variants
    if filename == "pipfile":
        return (True, "Pipfile")
    if filename == "pipfile.lock":
        return (True, "Pipfile.lock")

    return (False, "")
```

### 9.2 Alternative Command Generation

```python
def get_deny_message(file_type: str, file_path: str) -> str:
    """
    Generate appropriate denial message based on file type.

    Args:
        file_type: Type of dependency file
        file_path: Full path to the file

    Returns:
        Formatted error message with UV command alternatives
    """
    messages = {
        "uv.lock": """ðŸ”’ Blocked: Direct editing of UV lock file

File: {file_path}

UV lock files are automatically generated and should never be edited manually.

To update the lock file:
  uv lock                    # Regenerate lock file from dependencies
  uv lock --upgrade          # Upgrade all dependencies to latest compatible versions
  uv lock --upgrade-package <pkg>  # Upgrade specific package

To add dependencies:
  uv add <package>           # Add to dependencies and update lock
  uv add --dev <package>     # Add to dev dependencies

To remove dependencies:
  uv remove <package>        # Remove and update lock

Learn more: https://docs.astral.sh/uv/concepts/dependencies/""",

        "pyproject.toml": """ðŸ“¦ Blocked: Direct editing of pyproject.toml

File: {file_path}

Direct edits bypass UV's dependency management. Use UV commands for consistency.

Common operations:
  uv add <package>           # Add dependency
  uv add --dev <package>     # Add dev dependency
  uv add --optional <group> <package>  # Add to optional group
  uv remove <package>        # Remove dependency
  uv lock                    # Update lock file after changes

For non-dependency edits (metadata, tool config):
  - Temporarily disable this hook if needed
  - Use uv init for initial project setup

Learn more: https://docs.astral.sh/uv/concepts/dependencies/""",

        "requirements.txt": """ðŸ“‹ Blocked: Direct editing of requirements file

File: {file_path}

Direct edits to requirements.txt bypass UV's dependency resolution.

Migrate to modern UV workflow:
  uv add <package>           # Add dependency (updates pyproject.toml + uv.lock)
  uv remove <package>        # Remove dependency
  uv sync                    # Sync environment from lock file

If you must use requirements.txt:
  uv pip install <package>   # Install and update requirements.txt
  uv pip compile requirements.in -o requirements.txt  # Compile from .in file

Consider migrating to pyproject.toml for better dependency management.

Learn more: https://docs.astral.sh/uv/pip/compile/""",

        "Pipfile": """ðŸ”§ Blocked: Direct editing of Pipfile

File: {file_path}

Pipfile/Pipfile.lock should be managed by pipenv or migrated to UV.

If using Pipenv:
  pipenv install <package>   # Add dependency
  pipenv install --dev <package>  # Add dev dependency
  pipenv uninstall <package> # Remove dependency

Consider migrating to UV for better performance:
  # Export current dependencies
  pipenv requirements > requirements.txt

  # Migrate to UV
  uv init
  uv add $(cat requirements.txt | grep -v '^#' | grep -v '^-e')

Learn more: https://docs.astral.sh/uv/guides/projects/""",

        "Pipfile.lock": """ðŸ”§ Blocked: Direct editing of Pipfile.lock

File: {file_path}

Pipfile.lock is automatically generated by pipenv and should never be edited manually.

To update the lock file:
  pipenv lock                # Regenerate lock file
  pipenv update              # Update dependencies and lock file
  pipenv update <package>    # Update specific package

Consider migrating to UV for better performance:
  pipenv requirements > requirements.txt
  uv init && uv add $(cat requirements.txt | grep -v '^#')

Learn more: https://docs.astral.sh/uv/guides/projects/"""
    }

    template = messages.get(file_type, "")
    return template.format(file_path=file_path)
```

### 9.3 Main Validation Function

```python
def validate_file_operation(file_path: str) -> Optional[str]:
    """
    Validate that file operation is not targeting a dependency file.

    Args:
        file_path: Path to validate

    Returns:
        None if validation passes, error message string if validation fails
    """
    if not file_path:
        return None

    is_dep_file, file_type = is_dependency_file(file_path)

    if is_dep_file:
        return get_deny_message(file_type, file_path)

    return None
```

## 10. Error Handling Strategy

### Fail-Safe Principle

**All errors result in "allow" decision** to prevent disrupting development:

```python
try:
    # Validation logic
    pass
except Exception as e:
    # Log error to stderr
    print(f"UV dependency blocker error: {e}", file=sys.stderr)
    # Allow operation (fail-safe)
    output_decision("allow", f"Hook error (fail-safe): {e}")
```

### Error Scenarios

1. **Input Parsing Failure**:
   - Decision: Allow
   - Reason: "Failed to parse input (fail-safe)"

2. **Path Extraction Error**:
   - Decision: Allow
   - Behavior: Assume path is not a dependency file

3. **File Type Detection Error**:
   - Decision: Allow
   - Continue processing other validation checks

4. **Message Generation Error**:
   - Decision: Allow with generic message
   - Fallback to simple error message

## 11. Configuration

### 11.1 Hook Registration

**File**: `.claude/settings.json`

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "$CLAUDE_PROJECT_DIR/.claude/hooks/pre_tools/uv_dependency_blocker.py",
            "timeout": 60
          }
        ]
      }
    ]
  }
}
```

### 11.2 Hook Script Location

**Path**: `.claude/hooks/pre_tools/uv_dependency_blocker.py`

**Execution**: `uv run $CLAUDE_PROJECT_DIR/.claude/hooks/pre_tools/uv_dependency_blocker.py`

### 11.3 Environment Variables

- **CLAUDE_PROJECT_DIR**: Absolute path to project root
  - Used for robust path handling
  - Accessed via: `os.environ.get("CLAUDE_PROJECT_DIR", os.getcwd())`

## 12. Dependencies

### UV Script Metadata

```python
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///
```

### Python Version Requirement

- **Minimum**: Python 3.12
- **Rationale**: Use of modern type hints and pattern matching

### Standard Library Modules

```python
import os          # Path operations, environment variables
import sys         # stdin/stdout/stderr, exit codes
from typing import Optional, Tuple  # Type hints
```

### Shared Utilities

```python
from .utils import parse_hook_input, output_decision
```

**Imported Functions**:
- `parse_hook_input()` - Parse and validate JSON from stdin
- `output_decision()` - Output formatted JSON decision

## 13. Testing Strategy

### 13.1 Unit Tests Structure

**Location**: `tests/claude-hook/pre_tools/test_uv_dependency_blocker.py`

**Test Framework**: pytest with distributed testing

**Execution**: `uv run pytest -n auto tests/claude-hook/pre_tools/test_uv_dependency_blocker.py`

### 13.2 Test Categories

#### Dependency File Detection Tests

```python
def test_uv_lock_detection():
    """Test detection of uv.lock file."""
    assert is_dependency_file("uv.lock") == (True, "uv.lock")
    assert is_dependency_file("./uv.lock") == (True, "uv.lock")
    assert is_dependency_file("/project/uv.lock") == (True, "uv.lock")

def test_pyproject_toml_detection():
    """Test detection of pyproject.toml file."""
    assert is_dependency_file("pyproject.toml") == (True, "pyproject.toml")
    assert is_dependency_file("./pyproject.toml") == (True, "pyproject.toml")
    assert is_dependency_file("/project/pyproject.toml") == (True, "pyproject.toml")

def test_requirements_txt_variants():
    """Test detection of requirements.txt variants."""
    assert is_dependency_file("requirements.txt") == (True, "requirements.txt")
    assert is_dependency_file("requirements-dev.txt") == (True, "requirements.txt")
    assert is_dependency_file("requirements-test.txt") == (True, "requirements.txt")
    assert is_dependency_file("requirements-prod.txt") == (True, "requirements.txt")

def test_pipfile_detection():
    """Test detection of Pipfile and Pipfile.lock."""
    assert is_dependency_file("Pipfile") == (True, "Pipfile")
    assert is_dependency_file("Pipfile.lock") == (True, "Pipfile.lock")
    # Case-insensitive
    assert is_dependency_file("pipfile") == (True, "Pipfile")
    assert is_dependency_file("PIPFILE.LOCK") == (True, "Pipfile.lock")

def test_non_dependency_files():
    """Test that regular Python files are not detected."""
    assert is_dependency_file("main.py") == (False, "")
    assert is_dependency_file("requirements.md") == (False, "")
    assert is_dependency_file("test_requirements.txt") == (False, "")
    assert is_dependency_file("uv.py") == (False, "")
```

#### Path Handling Tests

```python
def test_absolute_path_detection():
    """Test dependency file detection with absolute paths."""
    assert is_dependency_file("/home/user/project/uv.lock")[0] is True
    assert is_dependency_file("/var/www/app/requirements.txt")[0] is True

def test_relative_path_detection():
    """Test dependency file detection with relative paths."""
    assert is_dependency_file("./requirements.txt")[0] is True
    assert is_dependency_file("../requirements-dev.txt")[0] is True
    assert is_dependency_file("docs/requirements.txt")[0] is True

def test_subdirectory_detection():
    """Test dependency files in subdirectories."""
    assert is_dependency_file("backend/requirements.txt")[0] is True
    assert is_dependency_file("services/api/pyproject.toml")[0] is True
```

#### Message Generation Tests

```python
def test_uv_lock_message_content():
    """Test that uv.lock denial message contains appropriate commands."""
    msg = get_deny_message("uv.lock", "uv.lock")
    assert "uv lock" in msg
    assert "never be edited manually" in msg
    assert "uv add" in msg

def test_pyproject_toml_message_content():
    """Test that pyproject.toml denial message contains appropriate commands."""
    msg = get_deny_message("pyproject.toml", "pyproject.toml")
    assert "uv add" in msg
    assert "uv remove" in msg
    assert "temporarily disable" in msg.lower()

def test_requirements_txt_message_content():
    """Test that requirements.txt denial message contains migration guidance."""
    msg = get_deny_message("requirements.txt", "requirements.txt")
    assert "uv add" in msg
    assert "migrate" in msg.lower() or "migrating" in msg.lower()
    assert "uv pip" in msg
```

#### Integration Tests

```python
def test_write_tool_blocked_uv_lock():
    """Test Write tool blocked when writing to uv.lock."""
    input_data = {
        "session_id": "test123",
        "transcript_path": "/path/to/transcript.jsonl",
        "cwd": "/project",
        "hook_event_name": "PreToolUse",
        "tool_name": "Write",
        "tool_input": {
            "file_path": "uv.lock",
            "content": "# Modified lock file"
        }
    }
    # Test that hook outputs "deny" decision

def test_edit_tool_blocked_pyproject():
    """Test Edit tool blocked when editing pyproject.toml."""
    input_data = {
        "session_id": "test123",
        "transcript_path": "/path/to/transcript.jsonl",
        "cwd": "/project",
        "hook_event_name": "PreToolUse",
        "tool_name": "Edit",
        "tool_input": {
            "file_path": "./pyproject.toml",
            "old_string": "old",
            "new_string": "new"
        }
    }
    # Test that hook outputs "deny" decision

def test_write_tool_allowed_regular_file():
    """Test Write tool allowed for non-dependency files."""
    input_data = {
        "session_id": "test123",
        "transcript_path": "/path/to/transcript.jsonl",
        "cwd": "/project",
        "hook_event_name": "PreToolUse",
        "tool_name": "Write",
        "tool_input": {
            "file_path": "main.py",
            "content": "print('hello')"
        }
    }
    # Test that hook outputs "allow" decision
```

#### Error Handling Tests

```python
def test_fail_safe_on_invalid_input():
    """Test hook allows operation on invalid JSON input."""
    # Mock malformed JSON
    # Verify "allow" decision output

def test_fail_safe_on_missing_file_path():
    """Test hook allows operation when file_path is missing."""
    input_data = {
        "tool_name": "Write",
        "tool_input": {}  # Missing file_path
    }
    # Verify "allow" decision output

def test_empty_file_path_handling():
    """Test hook handles empty file_path gracefully."""
    assert validate_file_operation("") is None
    assert validate_file_operation(None) is None
```

#### Cross-Platform Tests

```python
def test_windows_path_detection():
    """Test dependency file detection with Windows paths."""
    assert is_dependency_file("C:\\project\\uv.lock")[0] is True
    assert is_dependency_file("C:\\Users\\dev\\requirements.txt")[0] is True

def test_case_insensitive_matching():
    """Test case-insensitive file matching (Windows/macOS)."""
    assert is_dependency_file("UV.LOCK")[0] is True
    assert is_dependency_file("Requirements.TXT")[0] is True
    assert is_dependency_file("PyProject.Toml")[0] is True
```

### 13.3 Test Coverage Goals

- **Line Coverage**: â‰¥ 95%
- **Branch Coverage**: â‰¥ 90%
- **Edge Cases**: All documented edge cases tested
- **Platform Coverage**: Tests for Unix/Linux, macOS, Windows

### 13.4 Test Data

**Example Tool Inputs**:

```python
# Write tool - blocked (uv.lock)
WRITE_UV_LOCK_BLOCKED = {
    "session_id": "test123",
    "transcript_path": "/path/to/transcript.jsonl",
    "cwd": "/project",
    "hook_event_name": "PreToolUse",
    "tool_name": "Write",
    "tool_input": {
        "file_path": "uv.lock",
        "content": "# Manual edit"
    }
}

# Edit tool - blocked (pyproject.toml)
EDIT_PYPROJECT_BLOCKED = {
    "session_id": "test123",
    "transcript_path": "/path/to/transcript.jsonl",
    "cwd": "/project",
    "hook_event_name": "PreToolUse",
    "tool_name": "Edit",
    "tool_input": {
        "file_path": "./pyproject.toml",
        "old_string": "old_dep",
        "new_string": "new_dep"
    }
}

# Write tool - allowed (regular file)
WRITE_REGULAR_ALLOWED = {
    "session_id": "test123",
    "transcript_path": "/path/to/transcript.jsonl",
    "cwd": "/project",
    "hook_event_name": "PreToolUse",
    "tool_name": "Write",
    "tool_input": {
        "file_path": "src/main.py",
        "content": "print('hello')"
    }
}
```

## 14. Security Considerations

### 14.1 Input Validation

**Risk**: Malformed or malicious JSON input

**Mitigation**:
- Use shared `parse_hook_input()` utility
- Validate types before processing
- Fail-safe on errors (allow operation)

### 14.2 Path Safety

**Risk**: Path traversal or unusual path formats

**Mitigation**:
- Use `os.path.basename()` for filename extraction
- Case-insensitive matching via `.lower()`
- No path execution or file system modification

### 14.3 Error Message Safety

**Risk**: Exposing sensitive information in error messages

**Mitigation**:
- Only show file paths (which user already provided)
- No system information or environment details
- No internal hook implementation details
- Public documentation links only

### 14.4 Bypass Considerations

**Limitation**: Users can bypass via Bash tool

**Rationale**:
- This is workflow enforcement, not security
- Bash command parsing is too complex and error-prone
- Focus on catching accidental edits, not malicious bypasses
- Users can disable hook if needed

**Acceptable Risk**: Advanced users who intentionally bypass know what they're doing

## 15. Performance Considerations

### 15.1 Execution Time

**Target**: < 50ms per invocation

**Optimizations**:
- Simple string operations only
- No file system I/O
- No regex compilation
- Early return on non-Write/Edit tools
- Minimal path manipulation

### 15.2 Memory Usage

**Target**: < 5 MB per invocation

**Considerations**:
- Small string operations
- No large data structures
- Minimal allocations

### 15.3 Scalability

**Expected Load**: 10-100 hook invocations per minute

**Design**:
- Stateless execution (no shared state)
- No file I/O (except stdin/stdout)
- No network operations

## 16. Integration Considerations

### 16.1 Coexistence with Other Hooks

**Scenario**: Multiple PreToolUse hooks registered

**Behavior**:
- Hooks run in parallel
- Any "deny" decision blocks operation
- This hook uses `suppressOutput: true` to avoid spam

**Compatibility**:
- Works alongside universal_hook_logger.py
- Works alongside tmp_creation_blocker.py
- Compatible with other validation hooks
- No shared state or conflicts

### 16.2 User Experience

**Error Message Design**:
- Clear explanation of what was blocked
- Specific reasons why manual editing is problematic
- Concrete UV command alternatives with examples
- Helpful tone focused on best practices
- Links to official documentation

**Educational Value**:
- Teaches proper UV workflow
- Explains benefits of dependency management tools
- Provides migration guidance for legacy formats

### 16.3 Debugging Support

**Hook Execution Visibility**:
- Use `claude --debug` to see hook invocations
- Check logs in transcript mode (Ctrl-R)
- Error messages sent to stderr (visible in debug mode)

**Testing Hook Manually**:
```bash
# Test with sample input
echo '{"tool_name":"Write","tool_input":{"file_path":"uv.lock"}}' | \
  uv run .claude/hooks/pre_tools/uv_dependency_blocker.py

# Expected output: Deny decision with helpful message
```

## 17. Rollback Strategy

### 17.1 Disabling the Hook

**Option 1**: Comment out in settings.json
```json
{
  "hooks": {
    "PreToolUse": [
      // {
      //   "matcher": "Write|Edit",
      //   "hooks": [...uv_dependency_blocker...]
      // }
    ]
  }
}
```

**Option 2**: Use settings.local.json override
```json
{
  "hooks": {
    "PreToolUse": []
  }
}
```

**Option 3**: Delete hook script
```bash
rm .claude/hooks/pre_tools/uv_dependency_blocker.py
```

### 17.2 Partial Rollback

**Allow specific files** (requires code modification):
```python
# Add allow-list in hook script
ALLOWED_FILES = ["pyproject.toml"]  # Allow pyproject.toml edits

if filename in ALLOWED_FILES:
    return None  # Allow
```

**Disable for local development**:
- Create `.claude/settings.local.json` with empty hooks
- Gitignored by default

## 18. Future Enhancements

### 18.1 Configuration Options

**Potential Settings** (via environment variables or config file):

```python
# Allow-list for specific dependency files
ALLOWED_DEPENDENCY_FILES = ["requirements.txt"]

# Custom dependency file patterns
CUSTOM_DEPENDENCY_PATTERNS = ["constraints.txt"]

# Disable for specific directories
IGNORE_DIRECTORIES = ["vendor/", "third_party/"]
```

### 18.2 Advanced Features

1. **Content-Aware Validation**:
   - Parse pyproject.toml to detect dependency vs. metadata edits
   - Allow metadata-only changes
   - Block only dependency section edits

2. **Smart Suggestions**:
   - Detect specific package names in edit attempts
   - Suggest exact `uv add <package>` command

3. **Migration Assistance**:
   - Detect old requirements.txt and suggest migration
   - Generate migration commands automatically

4. **Analytics**:
   - Track blocked operations
   - Report common patterns
   - Suggest workflow improvements

### 18.3 Alternative Approaches

**"Ask" Permission Mode**:
- Use `permissionDecision: "ask"` instead of "deny"
- Allow user to override on a case-by-case basis
- Good for teams transitioning to UV workflow

**Warning Mode**:
- Allow operation but show warning
- Exit code 0 with warning message
- Non-blocking enforcement

## 19. Documentation Requirements

### 19.1 Inline Documentation

- Comprehensive module docstring
- Function docstrings with Args/Returns
- Type hints on all functions
- Comments for file pattern logic

### 19.2 User Documentation

**Topics to Cover**:
1. What the hook does and why
2. How to use UV commands for dependency management
3. How to temporarily disable if needed
4. Troubleshooting common issues
5. Migration guidance for different file formats

### 19.3 Developer Documentation

**Topics to Cover**:
1. Architecture and design decisions
2. How to extend for new file types
3. How to customize error messages
4. Testing procedures
5. Debugging techniques

## 20. Success Criteria

### 20.1 Functional Requirements

- âœ… Blocks direct edits to all common Python dependency files
- âœ… Provides specific UV command alternatives for each file type
- âœ… Works with files in any project location
- âœ… Case-insensitive file detection (cross-platform)
- âœ… Uses shared utilities from pre_tools/utils
- âœ… Fail-safe behavior on errors

### 20.2 Non-Functional Requirements

- âœ… Execution time < 50ms
- âœ… Test coverage â‰¥ 95%
- âœ… Zero external dependencies
- âœ… Clear, educational error messages
- âœ… No disruption to development workflow

### 20.3 Integration Requirements

- âœ… Registered in .claude/settings.json
- âœ… Works alongside other PreToolUse hooks
- âœ… Compatible with universal_hook_logger.py
- âœ… No conflicts with existing infrastructure

## 21. Implementation Plan

### Phase 1: Core Implementation

1. âœ… Create UV script with metadata
2. âœ… Implement dependency file detection logic
3. âœ… Implement file type categorization
4. âœ… Create file-type-specific error messages
5. âœ… Integrate with shared utilities
6. âœ… Add comprehensive docstrings

### Phase 2: Configuration

1. âœ… Add to .claude/settings.json
2. âœ… Configure tool matchers (Write, Edit only)
3. âœ… Set appropriate timeout (60 seconds)
4. âœ… Test hook registration

### Phase 3: Testing

1. â³ Write unit tests for file detection
2. â³ Write unit tests for message generation
3. â³ Write integration tests
4. â³ Write cross-platform tests
5. â³ Achieve â‰¥95% code coverage

### Phase 4: Documentation

1. â³ Complete inline documentation
2. â³ Write user guide (README section)
3. â³ Add examples and troubleshooting
4. â³ Update pre_tools/README.md

### Phase 5: Validation

1. â³ Manual testing with real Claude Code sessions
2. â³ Test on all supported platforms
3. â³ Validate error messages are helpful
4. â³ Performance testing

## 22. Specification Change Log

| Version | Date       | Changes                                      | Author                   |
|---------|------------|----------------------------------------------|--------------------------|
| 1.0.0   | 2025-10-30 | Initial specification                        | Claude Code Hook Expert  |

---

**Specification Status**: âœ… Ready for Implementation

**Next Steps**:
1. Review specification with stakeholders
2. Proceed to build phase using `/experts:cc_hook_expert:cc_hook_expert_build`
3. Implement comprehensive test suite
4. Deploy and validate in real-world usage

**Related Documents**:
- `.claude/hooks/pre_tools/utils/data_types.py` - Shared type definitions
- `.claude/hooks/pre_tools/utils/utils.py` - Shared utility functions
- `ai_docs/claude-code-hooks.md` - Claude Code hooks reference
- `ai_docs/uv-scripts-guide.md` - UV script execution guide
- [UV Dependencies Documentation](https://docs.astral.sh/uv/concepts/dependencies/)
- [UV pip interface Documentation](https://docs.astral.sh/uv/pip/)
